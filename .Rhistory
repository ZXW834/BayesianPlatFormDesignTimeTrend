#Storage object for posterior probabilities
if (variable.inf == "Fixeffect") {
if (reg.inf == "main") {
stats = matrix(NA,
nrow = length(ns),
ncol = K - 1 + K * 2 + K - 1 + 1 + K - 1 + K - 1)
#K-1 posterior probability better than control and K columns number of success + K columns number of patient
#K-1 Indicator of K-1 hypothesis
#1: control mean estimates Debugged at 02:25 10/10/2022 by ZIYAN WANG
#K-1 Mean estimates of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#K-1 Variance of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
}
else if (reg.inf == "main + stage_continuous") {
stats = matrix(NA,
nrow = length(ns),
ncol = K - 1 + K * 2 + K - 1 + 1 + K - 1 + K - 1 + 1)
#K-1 posterior probability better than control and K columns number of success + K columns number of patient
#K-1 Indicator of K-1 hypothesis
#1: control mean estimates Debugged at 02:25 10/10/2022 by ZIYAN WANG
#K-1 Mean estimates of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#K-1 Variance of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#1 Stage effect when stage is treated as continuous. Debugged at 22:00 16/09/2022 by ZIYAN WANG
}
else if (reg.inf == "main * stage_continuous") {
stats = matrix(NA,
nrow = length(ns),
ncol = K - 1 + K * 2 + K - 1 + 1 + K - 1 + K - 1 + 1 + K - 1)
#K-1 posterior probability better than control and K columns number of success + K columns number of patient
#K-1 Indicator of K-1 hypothesis
#1: control mean estimates Debugged at 02:25 10/10/2022 by ZIYAN WANG
#K-1 Mean estimates of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#K-1 Variance of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#1 Stage effect when stage is treated as continuous. Debugged at 22:00 16/09/2022 by ZIYAN WANG
#K-1 Interaction effect when stage is treated as continuous. Debugged at 22:00 16/09/2022 by ZIYAN WANG
}
else if (reg.inf == "main + stage_discrete") {
stats = matrix(NA,
nrow = length(ns),
ncol = K - 1 + K * 2 + K - 1 + 1 + K - 1 + K - 1 + length(ns) - 1)
#K-1 posterior probability better than control and K columns number of success + K columns number of patient
#K-1 Indicator of K-1 hypothesis
#1: control mean estimates Debugged at 02:25 10/10/2022 by ZIYAN WANG
#K-1 Mean estimates of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#K-1 Variance of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#length(ns)-1 Total number of Stage effect when stage is treated as discrete Debugged at 22:00 16/09/2022 by ZIYAN WANG
}
else if (reg.inf == "main * stage_discrete") {
stats = matrix(
NA,
nrow = length(ns),
ncol = K - 1 + K * 2 + K - 1 + 1 + K - 1 + K - 1 + length(ns) - 1 + (K -
1) * (length(ns) - 1)
)
#K-1 posterior probability better than control and K columns number of success + K columns number of patient
#K-1 Indicator of K-1 hypothesis
#1: control mean estimates Debugged at 02:25 10/10/2022 by ZIYAN WANG
#K-1 Mean estimates of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#K-1 Variance of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#length(ns)-1 Total number of Stage effect when stage is treated as discrete Debugged at 22:00 16/09/2022 by ZIYAN WANG
#(K-1)*(length(ns)-1) Total number of Interaction effect when stage is treated as discrete Debugged at 22:00 16/09/2022 by ZIYAN WANG
}
else{
stop(
"Error: reg.inf must be in c(main, main + stage_continuous, main * stage_continuous, main + stage_discrete, main * stage_discrete)"
)
}
#Debugged at 02:01 17/09/2022 by ZIYAN WANG. For compressing different version of codes.
#Use name function to assign the names of each column of stats matrix
namefunc = function(K, ns) {
ngroup = length(ns)
#probability of each treatment better than control
name1 = {
}
#number of patients in each arm and their outcomes
name2 = {
}
#Hypothesis testing result
name3 = {
}
#mean treatment effect
name4 = {
}
#varance of treatment effect
name5 = {
}
#mean Stage effect
name6 = {
}
#mean Interaction effect
name7 = {
}
#mean fix intercept
name8 = paste0("Intercept")
if (reg.inf == "main") {
for (n in 1:(K - 1)) {
name1 = c(name1, paste0("PP", n, "C"))
name2 = c(name2, paste0("nE", n), paste0("yE", n))
name3 = c(name3, paste0("H1^", n, "tpIE"))
name4 = c(name4, paste0("Trt", n, "_Mean"))
name5 = c(name5, paste0("Trt", n, "_Var"))
}
}
else if (reg.inf == "main + stage_continuous") {
for (n in 1:(K - 1)) {
name1 = c(name1, paste0("PP", n, "C"))
name2 = c(name2, paste0("nE", n), paste0("yE", n))
name3 = c(name3, paste0("H1^", n, "tpIE"))
name4 = c(name4, paste0("Trt", n, "_Mean"))
name5 = c(name5, paste0("Trt", n, "_Var"))
}
name6 = c(name6, paste0("stageeffect"))
}
else if (reg.inf == "main * stage_continuous") {
for (n in 1:(K - 1)) {
name1 = c(name1, paste0("PP", n, "C"))
name2 = c(name2, paste0("nE", n), paste0("yE", n))
name3 = c(name3, paste0("H1^", n, "tpIE"))
name4 = c(name4, paste0("Trt", n, "_Mean"))
name5 = c(name5, paste0("Trt", n, "_Var"))
name7 = c(name7, paste0("stage_treatment", n, "interaction"))
}
name6 = c(name6, paste0("stageeffect"))
}
else if (reg.inf == "main + stage_discrete") {
for (n in 1:(K - 1)) {
name1 = c(name1, paste0("PP", n, "C"))
name2 = c(name2, paste0("nE", n), paste0("yE", n))
name3 = c(name3, paste0("H1^", n, "tpIE"))
name4 = c(name4, paste0("Trt", n, "_Mean"))
name5 = c(name5, paste0("Trt", n, "_Var"))
}
for (grouptemp in 2:ngroup) {
name6 = c(name6, paste0("stageeffect_", grouptemp))
}
}
else if (reg.inf == "main * stage_discrete") {
for (n in 1:(K - 1)) {
name1 = c(name1, paste0("PP", n, "C"))
name2 = c(name2, paste0("nE", n), paste0("yE", n))
name3 = c(name3, paste0("H1^", n, "tpIE"))
name4 = c(name4, paste0("Trt", n, "_Mean"))
name5 = c(name5, paste0("Trt", n, "_Var"))
for (grouptemp in 2:ngroup) {
name7 = c(name7,
paste0("trt", n, "_stage", grouptemp, "interaction"))
}
}
for (grouptemp in 2:ngroup) {
name6 = c(name6, paste0("stageeffect_", grouptemp))
}
}
return(c(
name1,
"nC",
"yC",
name2,
name3,
name8,
name4,
name5,
name6,
name7
))
}
}
else if (variable.inf == "Mixeffect") {
stats = matrix(NA,
nrow = length(ns),
ncol = K - 1 + K * 2 + K - 1 + 1 + K - 1 + K - 1 + length(ns) - 1)
#K-1 posterior probability better than control and K columns number of success + K columns number of patient
#K-1 Indicator of K-1 hypothesis
#1: control mean estimates Debugged at 02:25 10/10/2022 by ZIYAN WANG
#K-1 Mean estimates of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#K-1 Variance of treatment effect at logit scale. Debugged at 14:52 05/09/2022 by ZIYAN WANG
#length(ns)-1 Total number of Stage effect when stage is treated as discrete Debugged at 22:00 16/09/2022 by ZIYAN WANG
namefunc = function(K, ns) {
ngroup = length(ns)
#probability of each treatment better than control
name1 = {
}
#number of patients in each arm and their outcomes
name2 = {
}
#Hypothesis testing result
name3 = {
}
#mean treatment effect
name4 = {
}
#varance of treatment effect
name5 = {
}
#mean Stage effect
name6 = {
}
#mean Interaction effect
name7 = {
}
#mean fix intercept
name8 = paste0("Intercept")
for (n in 1:(K - 1)) {
name1 = c(name1, paste0("PP", n, "C"))
name2 = c(name2, paste0("nE", n), paste0("yE", n))
name3 = c(name3, paste0("H1^", n, "tpIE"))
name4 = c(name4, paste0("Trt", n, "_Mean"))
name5 = c(name5, paste0("Trt", n, "_Var"))
}
for (grouptemp in 2:ngroup) {
name6 = c(name6, paste0("Randomintercept", grouptemp))
}
return(c(
name1,
"nC",
"yC",
name2,
name3,
name8,
name4,
name5,
name6,
name7
))
}
}
statsname = namefunc(K, ns)
colnames(stats) = statsname
rownames(stats) = 1:length(ns)
return(stats)
}
OutputStats.initialising(variable.inf = "Fixeffect", reg.inf = "main", ns = c(15, 30, 45, 60, 75), K = 2)
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
input.info = list(
response.probs = c(0.4, 0.4),
ns = c(30, 60, 90, 120, 150),
max.ar = 0.75,
rand.type = "Urn",
max.deviation = 3,
model.inf = list(
model = "tlr",
ibb.inf = list(
pi.star = 0.5,
pess = 2,
betabinomialmodel = ibetabinomial.post
),
tlr.inf = list(
beta0_prior_mu = 0,
beta1_prior_mu = 0,
beta0_prior_sigma = 2.5,
beta1_prior_sigma = 2.5,
beta0_df = 7,
beta1_df = 7,
reg.inf =  "main",
variable.inf = "Fixeffect"
)
),
Stopbound.inf = Stopboundinf(
Stop.type = "Early-Pocock",
Boundary.type = "Symmetric",
cutoff = c(0.99, 0.01)
),
Random.inf = list(
Fixratio = FALSE,
Fixratiocontrol = NA,
BARmethod = "Thall",
Thall.tuning.inf = list(tuningparameter = "Fixed",  fixvalue = 1)
),
trend.inf = list(
trend.type = "step",
trend.effect = c(0, 0),
trend_add_or_multip = "mult"
)
)
else{
trendornot = "NOTREND"
}
trendornot
paste0("TABLE",trendornot,input.info$Stopbound.inf$Stop.type,input.info$Stopbound.inf$Boundary.type)
paste0("TABLE",trendornot,toupper(input.info$Stopbound.inf$Stop.type),toupper(input.info$Stopbound.inf$Boundary.type))
roxygen2::roxygenize()
#'    The clinically meaningful increment on probability scale is 0.2. The stopping boundary is the OBF. The cutoff vector in the demo is tuned to keep Type I error rate to be 0.05
#'
#' @param ntrials A numeric value. The number of total trail replicates for each scenario.
#' @param cl A numeric variable indicating how many cores you want to use in parallel programming.
#'
#' @return Saved data file for plotting. One is results of trial replicates for all scenarios. The other one is a data frame containing all summarised evaluation metrics for all scenarios
#' @export
#'
#' @examples
#' demo_multscenario(nrtial = 100, cl = 2)
demo_multscenario = function(ntrials = 1000, cl = 2) {
ns = list(seq(60, 300, 60), seq(30, 300, 30)) #group size of 15 for a maximum sample size of 150
null.response.probs1 = 0.15
alt.response.probs1 = 0.35
null.response.probs2 = 0.4
alt.response.probs2 = 0.6
scenario = matrix(
c(
null.response.probs1,
null.response.probs1,
null.response.probs1,
alt.response.probs1,
null.response.probs2,
null.response.probs2,
null.response.probs2,
alt.response.probs2
),
ncol = 2,
nrow = 4,
byrow = T
)
cutoffearlyOBF = c(4.391, 4.661, 4.391, 4.661, 4.281, 4.512, 4.281, 4.512)
result = {
}
OPC = {
}
cutoffindex = 1
for (i in 1:dim(scenario)[1]) {
for (z in 1:length(ns)) {
restlr = Trial.simulation(
ntrials = ntrials,
trial.fun = simulatetrial,
input.info = list(
response.probs = scenario[i, ],
ns = ns[[z]],
max.ar = 0.75,
rand.type = "Urn",
max.deviation = 3,
model.inf = list(
model = "tlr",
ibb.inf = list(
pi.star = 0.5,
pess = 2,
betabinomialmodel = ibetabinomial.post
),
tlr.inf = list(
beta0_prior_mu = 0,
beta1_prior_mu = 0,
beta0_prior_sigma = 2.5,
beta1_prior_sigma = 2.5,
beta0_df = 7,
beta1_df = 7,
reg.inf =  "main",
variable.inf = "Fixeffect"
)
),
Stopbound.inf = Stopboundinf(
Stop.type = "Early-OBF",
Boundary.type = "Symmetric",
cutoff = c(cutoffearlyOBF[cutoffindex], cutoffearlyOBF[cutoffindex])
),
Random.inf = list(
Fixratio = FALSE,
Fixratiocontrol = NA,
BARmethod = "Thall",
Thall.tuning.inf = list(tuningparameter = "Fixed",  fixvalue = 1)
),
trend.inf = list(
trend.type = "step",
trend.effect = c(0, 0),
trend_add_or_multip = "mult"
)
),
cl = cl
)
cutoffindex = cutoffindex + 1
result = c(result, restlr$result)
OPC = rbind(OPC, restlr$OPC)
}
}
save(result, file = restlr$Nameofsaveddata$nameData)
save(OPC, file = restlr$Nameofsaveddata$nameTable)
}
demo_multscenario(nrtial = 10, cl = 2)
demo_multscenario(ntrial = 100, cl = 2)
#'    The clinically meaningful increment on probability scale is 0.2. The stopping boundary is the OBF. The cutoff vector in the demo is tuned to keep Type I error rate to be 0.05
#'
#' @param ntrials A numeric value. The number of total trail replicates for each scenario.
#' @param cl A numeric variable indicating how many cores you want to use in parallel programming.
#'
#' @return Saved data file for plotting. One is results of trial replicates for all scenarios. The other one is a data frame containing all summarised evaluation metrics for all scenarios
#' @export
#'
#' @examples
#' demo_multscenario(ntrials = 100, cl = 2)
demo_multscenario = function(ntrials = 1000, cl = 2) {
ns = list(seq(60, 300, 60), seq(30, 300, 30)) #group size of 15 for a maximum sample size of 150
null.response.probs1 = 0.15
alt.response.probs1 = 0.35
null.response.probs2 = 0.4
alt.response.probs2 = 0.6
scenario = matrix(
c(
null.response.probs1,
null.response.probs1,
null.response.probs1,
alt.response.probs1,
null.response.probs2,
null.response.probs2,
null.response.probs2,
alt.response.probs2
),
ncol = 2,
nrow = 4,
byrow = T
)
cutoffearlyOBF = c(4.391, 4.661, 4.391, 4.661, 4.281, 4.512, 4.281, 4.512)
result = {
}
OPC = {
}
cutoffindex = 1
for (i in 1:dim(scenario)[1]) {
for (z in 1:length(ns)) {
restlr = Trial.simulation(
ntrials = ntrials,
trial.fun = simulatetrial,
input.info = list(
response.probs = scenario[i, ],
ns = ns[[z]],
max.ar = 0.75,
rand.type = "Urn",
max.deviation = 3,
model.inf = list(
model = "tlr",
ibb.inf = list(
pi.star = 0.5,
pess = 2,
betabinomialmodel = ibetabinomial.post
),
tlr.inf = list(
beta0_prior_mu = 0,
beta1_prior_mu = 0,
beta0_prior_sigma = 2.5,
beta1_prior_sigma = 2.5,
beta0_df = 7,
beta1_df = 7,
reg.inf =  "main",
variable.inf = "Fixeffect"
)
),
Stopbound.inf = Stopboundinf(
Stop.type = "Early-OBF",
Boundary.type = "Symmetric",
cutoff = c(cutoffearlyOBF[cutoffindex], cutoffearlyOBF[cutoffindex])
),
Random.inf = list(
Fixratio = FALSE,
Fixratiocontrol = NA,
BARmethod = "Thall",
Thall.tuning.inf = list(tuningparameter = "Fixed",  fixvalue = 1)
),
trend.inf = list(
trend.type = "step",
trend.effect = c(0, 0),
trend_add_or_multip = "mult"
)
),
cl = cl
)
cutoffindex = cutoffindex + 1
result = c(result, restlr$result)
OPC = rbind(OPC, restlr$OPC)
}
}
save(result, file = restlr$Nameofsaveddata$nameData)
save(OPC, file = restlr$Nameofsaveddata$nameTable)
}
demo_multscenario(ntrials = 10, cl = 2)
demo_multscenario(ntrial = 100, cl = 2)
roxygen2::roxygenize()
warnings()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::install_github("Dschaykib/newsmd")
library(newsmd)
my_news <- news$new()
my_news <- newsmd()
my_news$add_version("1.0.0.9000")
my_news$get_text()
my_news <- news$new()
my_news <- newsmd()
my_news$add_version("1.0.0.9000")
my_news$get_text()
roxygen2::roxygenize()
View(my_news)
my_news <- news$new()
my_news <- newsmd()
my_news$get_text()
utils::news()
usethis::use_news_md()
use_readme_rmd()
usethis::use_readme_rmd()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::build_readme()
devtools::build_readme()
