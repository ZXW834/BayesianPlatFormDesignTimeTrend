change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
Q
set.seed(1)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
View(GP.res)
View(GP.res)
View(startgrid)
set.seed(2)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
set.seed(3)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
set.seed(4)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
set.seed(4)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
set.seed(4)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
GP.res = GP.optim(startgrid$cutoff, startgrid$tpIE, grid.min = grid.min,
grid.max = grid.max)
View(startgrid)
startgrid
startgrid$tpIErep(0,10)
startgrid
startgrid$tpIE=rep(0,10)
GP.res = GP.optim(startgrid$cutoff, startgrid$tpIE, grid.min = grid.min,
grid.max = grid.max)
for (j in 1:dim(startgrid)[1]) {
if (Boundary.type == "Symmetric") {
if (input.info$Stop.type == "Early-OBF") {
cutoff = c(startgrid[j, 2], startgrid[j, 2])
}
else {
cutoff = c(startgrid[j, 2], 1 - startgrid[j,
2])
}
}
else {
cutoff = c(startgrid[j, 2], startgrid[j, 3])
}
Stopbound.inf = Stopboundinf(Stop.type = input.info$Stop.type,
Boundary.type = input.info$Boundary.type, cutoff = cutoff)
result = foreach(icount(ntrials)) %dopar% trial.fun(response.probs = input.info$response.probs,
ns = input.info$ns, max.ar = input.info$max.ar,
rand.algo = input.info$rand.algo, max.deviation = input.info$max.deviation,
model.inf = input.info$model.inf, Stopbound.inf = Stopbound.inf,
Random.inf = input.info$Random.inf, trend.inf = input.info$trend.inf)
FWER = FWER_disconjunctivepowerfunc(result)
startgrid[j, 1] = FWER
}
set.seed(4)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
GP.res = GP.optim(startgrid$cutoff, startgrid$tpIE, grid.min = grid.min,
grid.max = grid.max)
set.seed(4)
tst=demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
grid.inf = list(
start.length = 10,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = TRUE,
errorrate = 0.1,
simulationerror = 0.01,
iter.max = 15,
plotornot = FALSE))
GP.res = GP.optim(startgrid$cutoff, startgrid$tpIE, grid.min = grid.min,
grid.max = grid.max)
View(startgrid)
debug(GP.optim)
GP.res = GP.optim(startgrid$cutoff, startgrid$tpIE, grid.min = grid.min,
grid.max = grid.max)
GP.res = GP.optim(startgrid$cutoff, startgrid$tpIE, grid.min = grid.min,
grid.max = grid.max)
target
grid.new[which(target)]
?sample
sample(1, 1, replace = T, prob = 1)
sample(potentialcutoff, 1, replace = T, prob = randomprobability)
sample(potentialcutoff, 1, replace = T, prob = 1)
sample(2, 1, replace = T, prob = 1)
sample(2, 1, replace = T)
sample(2, 1, replace = T)
sample(2, 1, replace = T)
sample(2, 1, replace = T)
sample(2, 1, replace = T)
sample(c(2), 1, replace = T)
sample(c(2), 1, replace = T)
GP.res = GP.optim(startgrid$cutoff, startgrid$tpIE, grid.min = grid.min,
grid.max = grid.max)
sample(x=2, 1, replace = T)
sample(x=2, 1, replace = T)
sample(x=2, 1, replace = T,prob=1)
sample(vector(2), 1, replace = T,prob=1)
sample(as.vector(2), 1, replace = T,prob=1)
sample(as.vector(c(2)), 1, replace = T,prob=1)
#' 0.1040, 0.3058,
#' 0.0592, 0.1384,
#' 0.0296, 0.7936)
#' grid.min=1
#' grid.max=8
#' GP.res=GP.optim(x=x, y=y, errorrate = 0.1, grid.min = grid.min, grid.max = grid.max)
#' GP.res$next.cutoff
#' @references Surrogates: Gaussian process modeling, design, and optimization for the applied sciences. CRC press. Gramacy, R.B., 2020.
#'    Bayesian optimization for adaptive experimental design: A review. IEEE access, 8, 13937-13948. Greenhill, S., Rana, S., Gupta, S., Vellanki, P., & Venkatesh, S. (2020).
#' @author Ziyan Wang
GP.optim = function(x,
y,
errorrate = 0.05,
confidence.level = 0.95,
grid.length = 5000,
change.scale = FALSE,
noise = T,
grid.min,
grid.max) {
# Debug here for GP model with Bayesian optimisation on April 25, 2023
eps = .Machine$double.eps
# loglikelihood function
nlg = function(g, D, y) {
n = length(y)
K = exp(-D) + diag(g, n)
Ki = solve(K)
logdetK = determinant(K, logarithm = T)$modulus
loglike = -(n / 2) * log(t(y) %*% Ki %*% y) - 0.5 * logdetK
return(-loglike)
}
D = distance(x)
if (noise) {
g = optimize(nlg,
interval = c(eps ^ 0.5, var(y)),
D = D,
y = y)$minimum
}
gridx = seq(grid.min, grid.max, length.out = grid.length)
if (change.scale) {
grid.new = (gridx - min(x)) / (max(x) - min(x))
x.new = (x - min(x)) / (max(x) - min(x))
}
else{
x.new = x
grid.new = gridx
}
D = distance(x.new)
K = exp(-D) + diag(g, ncol(D))
DXX = distance(grid.new)
KXX = exp(-DXX) + diag(g, ncol(DXX))
DX = distance(grid.new, x.new)
KX = exp(-DX)
Ki = solve(K)
yhat = KX %*% Ki %*% y
tau_squared = drop(t(y) %*% Ki %*% y / length(y))
sigma = tau_squared * (KXX - KX %*% Ki %*% t(KX))
sd = sqrt(abs(diag(sigma)))
# construct confidence interval
qup = yhat + qnorm(confidence.level, 0, sd)
qdown = yhat - qnorm(confidence.level, 0, sd)
# GP finished
# Bayesian optimisation start
# construct the target. The ideal value should locate in (errorrate - 1%, errorrate + 1%)
target = abs(yhat - errorrate) <= errorrate / 100
# construct the potential cutoff set
potentialcutoff = grid.new[which(target)]
e = 1e-10
weighs = sqrt(1 / (abs(grid.new[target] - errorrate) + e) * abs(diag(sigma))[which(target)])
randomprobability = weighs / sum(weighs)
# randomise the next value from the potential set
# Debugged on 11/06/2023 by Ziyan wang. Cran check and find one error due to the use of sample()
if (length(potentialcutoff) > 1){
next.cutoff = sample(potentialcutoff, 1, replace = T, prob = randomprobability)
}
else {
next.cutoff = potentialcutoff[sample(length(potentialcutoff), 1, replace = T, prob = randomprobability)]
}
return(list(
next.cutoff = next.cutoff,
prediction = list(
yhat = yhat,
sd = sd,
qup = qup,
qdown = qdown,
xgrid = grid.new
)
))
}
usethis::use_readme_rmd()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
roxygen2::roxygenise()
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
library(BayesianPlatformDesignTimeTrend)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
roxygen2::roxygenise()
remove.packages("BayesianPlatformDesignTimeTrend")
roxygen2::roxygenise()
?knitr
?knitr::opts_chunk$set
?knitr::opts_chunk
knitr::opts_chunk
knitr::opts_chunk$set()
knitr::opts_chunk$set
roxygen2::roxygenise()
install.packages("knitr")
install.packages("knitr")
roxygen2::roxygenise()
install.packages("BayesianPlatformDesignTimeTrend")
simulatetrial(response.probs = c(0.4, 0.6,0.4,0.4),
ns = c(30, 60, 90, 120, 150)*4,
max.ar = 0.85,
rand.algo = "Urn",
max.deviation = 3,
model.inf = list(
model = "tlr",
ibb.inf = list(
pi.star = 0.5,
pess = 2,
betabinomialmodel = ibetabinomial.post
),
tlr.inf = list(
beta0_prior_mu = 0,
beta1_prior_mu = 0,
beta0_prior_sigma = 2.5,
beta1_prior_sigma = 2.5,
beta0_df = 7,
beta1_df = 7,
reg.inf =  "main",
variable.inf = "Fixeffect"
)
),
Stopbound.inf = Stopboundinf(
Stop.type = "Early-Pocock",
Boundary.type = "Symmetric",
cutoff = c(0.99,0.01)
),
Random.inf = list(
Fixratio = FALSE,
Fixratiocontrol = NA,
BARmethod = "Thall",
Thall.tuning.inf = list(tuningparameter = "Unfixed",  fixvalue = NA)
),
trend.inf = list(
trend.type = "step",
trend.effect = c(0, 0),
trend_add_or_multip = "mult"
))
debug(simulatetrial)
simulatetrial(response.probs = c(0.4, 0.6,0.4,0.4),
ns = c(30, 60, 90, 120, 150)*4,
max.ar = 0.85,
rand.algo = "Urn",
max.deviation = 3,
model.inf = list(
model = "tlr",
ibb.inf = list(
pi.star = 0.5,
pess = 2,
betabinomialmodel = ibetabinomial.post
),
tlr.inf = list(
beta0_prior_mu = 0,
beta1_prior_mu = 0,
beta0_prior_sigma = 2.5,
beta1_prior_sigma = 2.5,
beta0_df = 7,
beta1_df = 7,
reg.inf =  "main",
variable.inf = "Fixeffect"
)
),
Stopbound.inf = Stopboundinf(
Stop.type = "Early-Pocock",
Boundary.type = "Symmetric",
cutoff = c(0.99,0.01)
),
Random.inf = list(
Fixratio = FALSE,
Fixratiocontrol = NA,
BARmethod = "Thall",
Thall.tuning.inf = list(tuningparameter = "Unfixed",  fixvalue = NA)
),
trend.inf = list(
trend.type = "step",
trend.effect = c(0, 0),
trend_add_or_multip = "mult"
))
zdropped
data
model.inf$tlr.inf$variable.inf
processedfitresult
names(processedfitresult)
post.prob.best
for (q in 1:armleft) {
post.prob.best.mat[group, zlevel[q]] =mean(max.col(sampefftotal) == q)
}
post.prob.best = post.prob.best.mat[group,]
#Normalizing in case any value equals zero
post.prob.best = post.prob.best + 1e-7
post.prob.best = post.prob.best / sum(post.prob.best)
post.prob.best
randomprob
?ARMAacf
?ARmethod
ARmethod(
Fixratio,
BARmethod,
group,
stats,
post.prob.btcontrol,
K,
n,
tuningparameter,
c,
post.prob.best,
max.ar,
armleft,
treatmentindex
)
debug(ARmethod)
ARmethod(
Fixratio,
BARmethod,
group,
stats,
post.prob.btcontrol,
K,
n,
tuningparameter,
c,
post.prob.best,
max.ar,
armleft,
treatmentindex
)
alloc.prob.best
randomprob
rpk
force(n)
\
debug(AdaptiveRandomisation)
AdaptiveRandomisation(
Fixratio,
rand.algo,
K,
n.new,
randomprob,
treatmentindex,
groupwise.response.probs,
group,
armleft,
max.deviation,
trend_add_or_multip,
trend.function,
trend.effect,
ns,
Fixratiocontrol
)
nstage
ystage
znew
ynew
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-06-25")
cranlogs::cran_downloads("gsDesign2",from = "2023-06-25")
cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-06-15")
cranlogs::cran_downloads("gsDesign2",from = "2023-06-15")
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-06-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-06-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-05-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-05-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-04-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-04-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
cranlogs::cran_downloads("gsMAMS",from = "2023-06-15")
cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-06-15")
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsMAMS",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("gsDesign2",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("NCC",from = "2023-03-01")$count)
sum(cranlogs::cran_downloads("BayesianPlatformDesignTimeTrend",from = "2023-03-01")$count)
